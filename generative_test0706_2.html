<!DOCTYPE html>

<html>

<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title> three.js try-1 </title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}
	</style>
</head>

<body>
	<script src="js/cell.js"></script>

	<script src="js/three.js"></script>

	<!-- include jsartookit -->
	<script src="AR-Examples-master/jsartoolkit5/artoolkit.min.js"></script>
	<script src="AR-Examples-master/jsartoolkit5/artoolkit.api.js"></script>

	<!-- include threex.artoolkit -->
	<script src="AR-Examples-master/threex/threex-artoolkitsource.js"></script>
	<script src="AR-Examples-master/threex/threex-artoolkitcontext.js"></script>
	<script src="AR-Examples-master/threex/threex-arbasecontrols.js"></script>
	<script src="AR-Examples-master/threex/threex-armarkercontrols.js"></script>

	<script>
		// Our Javascript will go here.


		const cellSize = 50;
		let cellNum = cellSize * cellSize;

		let cells = [];

		let scene, camera, renderer;

		// let texturePlane = THREE.ImageUtils.loadTexture('markers_img/test2.png');
		let texturePlane = new THREE.TextureLoader().load('markers_img/test2.png');
		let imgSize = 128;

		init();
		animate();

		function getRandomArbitrary(min, max) {
			return Math.random() * (max - min) + min;
		}

		function getRandomInt(min, max) {
			min = Math.ceil(min);
			max = Math.floor(max);
			return Math.floor(Math.random() * (max - min)) + min; //최댓값은 제외, 최솟값은 포함
		}

		function init() {
			renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			// if want lower resolution, setSize(window.innerWidth/2, window.innerHeight/2, false)
			document.body.appendChild(renderer.domElement);

			scene = new THREE.Scene();

			let ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
			scene.add(ambientLight);

			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
			//field of view, aspect ratio, near clipping plane, far clipping plane

			let geometryPlane = new THREE.PlaneBufferGeometry(imgSize, imgSize);
			let materialPlane = new THREE.MeshBasicMaterial({ map: texturePlane });
			let plane = new THREE.Mesh(geometryPlane, materialPlane);
			plane.position.x = 0;
			plane.position.y = 0;
			scene.add(plane);

			// set plane (=일종의 배지)
			for (let y = 1; y <= cellSize + 1; ++y) {
				for (let x = 1; x <= cellSize + 1; ++x) {
					cells[x * y] = new Cell(x, y, 1, Math.random(), Math.random(), Math.random());
					// cells.forEach(c=> scene.add(c.cube));
				}
			}

			camera.position.set(cellSize / 2, cellSize / 2, cellSize * 2);
		}

		function update() {
			// for (let y = 1; y <= cellSize + 1; ++y) {
			// 	for (let x = 1; x <= cellSize + 1; ++x) {
			// 		if (cells.length < cellSize * cellSize * cellSize) {
			// 			if (cells[x * y].readyToMitosis() == true) {
			// 				cells.push(cells[x * y].mitosis(x, y));
			// 				console.log(cells.length);
			// 			}
			// 		}
			// 	}
			// }
		}

		function animate() {
			requestAnimationFrame(animate);
			update();
			renderer.render(scene, camera);
		}
	</script>
</body>

</html>
