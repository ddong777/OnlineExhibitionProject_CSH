<!DOCTYPE html>

<html>

<head>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title> three.js try-0706 </title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			display: block;
		}
	</style>
</head>

<body>
	<script src="js/cell.js"></script>

	<script src="js/three.js"></script>

	<!-- include jsartookit -->
	<script src="AR-Examples-master/jsartoolkit5/artoolkit.min.js"></script>
	<script src="AR-Examples-master/jsartoolkit5/artoolkit.api.js"></script>

	<!-- include threex.artoolkit -->
	<script src="AR-Examples-master/threex/threex-artoolkitsource.js"></script>
	<script src="AR-Examples-master/threex/threex-artoolkitcontext.js"></script>
	<script src="AR-Examples-master/threex/threex-arbasecontrols.js"></script>
	<script src="AR-Examples-master/threex/threex-armarkercontrols.js"></script>

	<script>
		// Our Javascript will go here.
		const cellSize = 80;
		const cellNum = cellSize * cellSize;

		let cells = [];

		let scene, camera, renderer;

		init();
		animate();

		function getRandomArbitrary(min, max) {
			return Math.random() * (max - min) + min;
		}

		function getRandomInt(min, max) {
			min = Math.ceil(min);
			max = Math.floor(max);
			return Math.floor(Math.random() * (max - min)) + min; //최댓값은 제외, 최솟값은 포함
		}

		function init() {
			scene = new THREE.Scene();

			let ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
			scene.add(ambientLight);

			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			//field of view, aspect ratio, near clipping plane, far clipping plane
			renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			// if want lower resolution, setSize(window.innerWidth/2, window.innerHeight/2, false)
			document.body.appendChild(renderer.domElement);

			// set plane (=일종의 배지)
			for (let y = 0; y < cellSize; ++y) {
				for (let x = 0; x < cellSize; ++x) {
					cells[cellNum] = new Cell(x, y, 1, Math.random(), Math.random(), Math.random());
					// cells.forEach(c=> scene.add(c.cube));
					scene.add(cells[cellNum].cube);
				}
			}

			camera.position.set(cellSize / 2, cellSize / 2, cellSize);
		}

		function update() {
			for (let y = 0; y < cellSize; ++y) {
				for (let x = 0; x < cellSize; ++x) {
					if (cells.length < cellNum * cellSize) {
						if (cells[cellNum].readyToMitosis() == true) {
							cells.push(cells[cellNum].mitosis());
						}
					}
				}
			}
		}

		function animate() {
			requestAnimationFrame(animate);
			update();
			renderer.render(scene, camera);			
		}
	</script>
</body>

</html>
